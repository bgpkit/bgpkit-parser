//! Phase 2: Visualize the time difference data
//!
//! This script reads the CSV data generated by Phase 1 and creates:
//! 1. A line chart showing time_diff_secs distribution for route-views2 and rrc00
//! 2. A bar chart showing top 20 ASNs with the largest average time_diff_secs
//! 3. A summary statistics file (summary.txt)

use csv::Reader;
use plotters::prelude::*;
use serde::Deserialize;
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;

/// Record structure for CSV input
#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct TimeDiffRecord {
    collector: String,
    prefix: String,
    origin_asn: u32,
    time_diff_secs: i64,
}

// Define a consistent font family
const FONT_FAMILY: &str = "sans-serif";

fn main() {
    println!("=== RIB Time Difference Study - Phase 2: Visualization ===\n");

    // Read CSV data
    let input_path = "output/rib_time_diff.csv";
    println!("Reading data from {}...", input_path);

    let file =
        File::open(input_path).expect("Failed to open input CSV file. Run phase1_collect first!");
    let mut reader = Reader::from_reader(file);

    let records: Vec<TimeDiffRecord> = reader.deserialize().filter_map(|r| r.ok()).collect();

    println!("Loaded {} records", records.len());

    // Separate data by collector
    let route_views_data: Vec<&TimeDiffRecord> = records
        .iter()
        .filter(|r| r.collector == "route-views2")
        .collect();

    let rrc00_data: Vec<&TimeDiffRecord> =
        records.iter().filter(|r| r.collector == "rrc00").collect();

    println!("  route-views2: {} entries", route_views_data.len());
    println!("  rrc00: {} entries", rrc00_data.len());

    // Generate plots
    println!("\nGenerating visualizations...");

    let (_route_views_bins, _rrc00_bins) =
        generate_distribution_plot(&route_views_data, &rrc00_data)
            .expect("Failed to generate distribution plot");
    println!("  ✓ Created output/time_diff_distribution.png");

    let top_asns = generate_top_asn_plot(&records).expect("Failed to generate top ASN plot");
    println!("  ✓ Created output/top_asn_time_diff.png");

    generate_summary(&route_views_data, &rrc00_data, &top_asns)
        .expect("Failed to generate summary");
    println!("  ✓ Created output/summary.txt");

    println!("\nPhase 2 complete! Check the output/ directory for PNG files and summary.");
}

/// Generate summary statistics file
fn generate_summary(
    route_views_data: &[&TimeDiffRecord],
    rrc00_data: &[&TimeDiffRecord],
    top_asns: &[(u32, f64, usize)],
) -> Result<(), Box<dyn std::error::Error>> {
    let mut file = File::create("output/summary.txt")?;

    writeln!(file, "=== RIB Time Difference Study Summary ===")?;
    writeln!(file, "Dump timestamp: 2025-01-01T00:00:00Z")?;
    writeln!(file)?;

    // Overall stats
    let total_entries = route_views_data.len() + rrc00_data.len();
    writeln!(file, "## Overall Statistics")?;
    writeln!(file, "Total entries: {}", total_entries)?;
    writeln!(file)?;

    // Route-views2 stats
    let rv_times: Vec<i64> = route_views_data.iter().map(|r| r.time_diff_secs).collect();
    let rv_avg = rv_times.iter().sum::<i64>() as f64 / rv_times.len() as f64;
    let rv_min = *rv_times.iter().min().unwrap_or(&0);
    let rv_max = *rv_times.iter().max().unwrap_or(&0);
    let mut rv_sorted = rv_times.clone();
    rv_sorted.sort();
    let rv_median = rv_sorted.get(rv_sorted.len() / 2).copied().unwrap_or(0);

    writeln!(file, "## route-views2 Statistics")?;
    writeln!(file, "Entries: {}", route_views_data.len())?;
    writeln!(
        file,
        "Average age: {:.2} days ({:.2} hours)",
        rv_avg / 86400.0,
        rv_avg / 3600.0
    )?;
    writeln!(
        file,
        "Median age: {:.2} days ({:.2} hours)",
        rv_median as f64 / 86400.0,
        rv_median as f64 / 3600.0
    )?;
    writeln!(
        file,
        "Min age: {:.2} days ({:.2} hours)",
        rv_min as f64 / 86400.0,
        rv_min as f64 / 3600.0
    )?;
    writeln!(
        file,
        "Max age: {:.2} days ({:.2} hours)",
        rv_max as f64 / 86400.0,
        rv_max as f64 / 3600.0
    )?;
    writeln!(file)?;

    // rrc00 stats
    let rrc_times: Vec<i64> = rrc00_data.iter().map(|r| r.time_diff_secs).collect();
    let rrc_avg = rrc_times.iter().sum::<i64>() as f64 / rrc_times.len() as f64;
    let rrc_min = *rrc_times.iter().min().unwrap_or(&0);
    let rrc_max = *rrc_times.iter().max().unwrap_or(&0);
    let mut rrc_sorted = rrc_times.clone();
    rrc_sorted.sort();
    let rrc_median = rrc_sorted.get(rrc_sorted.len() / 2).copied().unwrap_or(0);

    writeln!(file, "## rrc00 Statistics")?;
    writeln!(file, "Entries: {}", rrc00_data.len())?;
    writeln!(
        file,
        "Average age: {:.2} days ({:.2} hours)",
        rrc_avg / 86400.0,
        rrc_avg / 3600.0
    )?;
    writeln!(
        file,
        "Median age: {:.2} days ({:.2} hours)",
        rrc_median as f64 / 86400.0,
        rrc_median as f64 / 3600.0
    )?;
    writeln!(
        file,
        "Min age: {:.2} days ({:.2} hours)",
        rrc_min as f64 / 86400.0,
        rrc_min as f64 / 3600.0
    )?;
    writeln!(
        file,
        "Max age: {:.2} days ({:.2} hours)",
        rrc_max as f64 / 86400.0,
        rrc_max as f64 / 3600.0
    )?;
    writeln!(file)?;

    // Top ASNs
    writeln!(file, "## Top 20 ASNs with Oldest Entries")?;
    writeln!(file, "Rank | ASN | Avg Age (days) | Prefix Count")?;
    writeln!(file, "-----|-----|----------------|-------------")?;
    for (rank, (asn, avg, count)) in top_asns.iter().enumerate() {
        writeln!(
            file,
            "{:4} | AS{} | {:.2} | {}",
            rank + 1,
            asn,
            avg / 86400.0,
            count
        )?;
    }

    Ok(())
}

/// Generate a line chart showing time difference distribution
/// Returns the binned data for both collectors
fn generate_distribution_plot(
    route_views_data: &[&TimeDiffRecord],
    rrc00_data: &[&TimeDiffRecord],
) -> Result<(Vec<(i64, u64)>, Vec<(i64, u64)>), Box<dyn std::error::Error>> {
    // Bin the data by time difference (in seconds)
    // Use bins of 1 hour (3600 seconds) for cleaner visualization
    let bin_size: i64 = 3600; // 1 hour bins
    let max_hours = 168; // Show up to 7 days (168 hours)

    let route_views_bins = bin_data(route_views_data, bin_size, max_hours);
    let rrc00_bins = bin_data(rrc00_data, bin_size, max_hours);

    // Find max count for Y axis
    let max_count = route_views_bins
        .iter()
        .chain(rrc00_bins.iter())
        .map(|(_, count)| *count)
        .max()
        .unwrap_or(1) as f64;

    // Create the plot
    let root =
        BitMapBackend::new("output/time_diff_distribution.png", (1200, 800)).into_drawing_area();
    root.fill(&WHITE)?;

    let title_style = (FONT_FAMILY, 28).into_font().color(&BLACK);
    let label_style = (FONT_FAMILY, 18).into_font().color(&BLACK);
    let axis_style = (FONT_FAMILY, 16).into_font().color(&BLACK);

    let mut chart = ChartBuilder::on(&root)
        .caption(
            "RIB Entry Age Distribution (Time Since Last Update)",
            title_style,
        )
        .margin(30)
        .x_label_area_size(60)
        .y_label_area_size(100)
        .build_cartesian_2d(0f64..(max_hours as f64), 0f64..max_count * 1.1)?;

    chart
        .configure_mesh()
        .x_desc("Hours since last update")
        .y_desc("Number of prefixes")
        .x_label_style(axis_style.clone())
        .y_label_style(axis_style.clone())
        .axis_desc_style(label_style.clone())
        .x_label_formatter(&|x| format!("{:.0}", x))
        .y_label_formatter(&|y| format!("{:.0}", y))
        .draw()?;

    // Draw route-views2 line
    chart
        .draw_series(LineSeries::new(
            route_views_bins
                .iter()
                .map(|(hour, count)| (*hour as f64, *count as f64)),
            BLUE.stroke_width(3),
        ))?
        .label("route-views2")
        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 25, y)], BLUE.stroke_width(3)));

    // Draw rrc00 line
    chart
        .draw_series(LineSeries::new(
            rrc00_bins
                .iter()
                .map(|(hour, count)| (*hour as f64, *count as f64)),
            RED.stroke_width(3),
        ))?
        .label("rrc00")
        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 25, y)], RED.stroke_width(3)));

    chart
        .configure_series_labels()
        .background_style(WHITE.mix(0.9))
        .border_style(BLACK)
        .position(SeriesLabelPosition::UpperRight)
        .label_font((FONT_FAMILY, 18).into_font())
        .draw()?;

    root.present()?;
    Ok((route_views_bins, rrc00_bins))
}

/// Bin data by time difference
fn bin_data(data: &[&TimeDiffRecord], bin_size: i64, max_hours: i64) -> Vec<(i64, u64)> {
    let mut bins: HashMap<i64, u64> = HashMap::new();

    for record in data {
        // Convert seconds to hours for binning
        let hour = record.time_diff_secs / bin_size;
        if hour >= 0 && hour < max_hours {
            *bins.entry(hour).or_insert(0) += 1;
        }
    }

    // Convert to sorted vector
    let mut result: Vec<(i64, u64)> = (0..max_hours)
        .map(|h| (h, *bins.get(&h).unwrap_or(&0)))
        .collect();
    result.sort_by_key(|(h, _)| *h);
    result
}

/// Generate a bar chart showing top 20 ASNs with largest average time_diff
/// Returns the top 20 ASNs data for use in summary
fn generate_top_asn_plot(
    records: &[TimeDiffRecord],
) -> Result<Vec<(u32, f64, usize)>, Box<dyn std::error::Error>> {
    // Calculate average time_diff per ASN (using all records from both collectors)
    let mut asn_time_diffs: HashMap<u32, Vec<i64>> = HashMap::new();

    for record in records {
        asn_time_diffs
            .entry(record.origin_asn)
            .or_default()
            .push(record.time_diff_secs);
    }

    // Calculate average and filter to ASNs with at least 10 prefixes
    let mut asn_averages: Vec<(u32, f64, usize)> = asn_time_diffs
        .into_iter()
        .filter(|(_, times)| times.len() >= 10)
        .map(|(asn, times)| {
            let avg = times.iter().sum::<i64>() as f64 / times.len() as f64;
            let count = times.len();
            (asn, avg, count)
        })
        .collect();

    // Sort by average time_diff descending and take top 20
    asn_averages.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    let top_20: Vec<_> = asn_averages.into_iter().take(20).collect();

    if top_20.is_empty() {
        println!("  Warning: No ASNs with enough data for top ASN chart");
        return Ok(top_20);
    }

    // Find max average for Y axis (convert to days)
    let max_avg_days = top_20
        .iter()
        .map(|(_, avg, _)| avg / 86400.0)
        .fold(0.0f64, f64::max);

    // Create the plot
    let root = BitMapBackend::new("output/top_asn_time_diff.png", (1200, 800)).into_drawing_area();
    root.fill(&WHITE)?;

    let title_style = (FONT_FAMILY, 28).into_font().color(&BLACK);
    let label_style = (FONT_FAMILY, 18).into_font().color(&BLACK);
    let axis_style = (FONT_FAMILY, 14).into_font().color(&BLACK);

    let mut chart = ChartBuilder::on(&root)
        .caption(
            "Top 20 ASNs with Oldest RIB Entries (Average Age)",
            title_style,
        )
        .margin(30)
        .x_label_area_size(100)
        .y_label_area_size(80)
        .build_cartesian_2d(
            (0..top_20.len()).into_segmented(),
            0f64..max_avg_days * 1.15,
        )?;

    chart
        .configure_mesh()
        .x_desc("Origin ASN")
        .y_desc("Average age (days)")
        .x_label_style(axis_style.clone())
        .y_label_style(axis_style.clone())
        .axis_desc_style(label_style.clone())
        .x_label_formatter(&|x| match x {
            SegmentValue::CenterOf(idx) => {
                if *idx < top_20.len() {
                    format!("AS{}", top_20[*idx].0)
                } else {
                    String::new()
                }
            }
            _ => String::new(),
        })
        .x_labels(20)
        .y_label_formatter(&|y| format!("{:.0}", y))
        .draw()?;

    // Draw bars
    chart.draw_series(
        Histogram::vertical(&chart)
            .style(BLUE.mix(0.7).filled())
            .data(
                top_20
                    .iter()
                    .enumerate()
                    .map(|(idx, (_, avg, _))| (idx, avg / 86400.0)),
            ),
    )?;

    // Add prefix count annotations on bars
    for (idx, (_asn, avg, count)) in top_20.iter().enumerate() {
        let avg_days = avg / 86400.0;
        chart.draw_series(std::iter::once(Text::new(
            format!("{} pfx", count),
            (SegmentValue::CenterOf(idx), avg_days + max_avg_days * 0.02),
            (FONT_FAMILY, 11).into_font().color(&BLACK),
        )))?;
    }

    root.present()?;
    Ok(top_20)
}
